给你一个由 不同 正整数组成的数组 nums ，请你返回满足 a * b = c * d 的元组 (a, b, c, d) 的数量。其中 a、b、c 和 d 都是 nums 中的元素，且 a != b != c != d 。

思路：哈希 + 数学
头疼的TLE：先固定两个位置，双指针遍历剩余位置，时间复杂度O(n^3)，不可取
哈希表记录乘积
从示例 1 可以看出，我们只要找到一个 (a,b,c,d)标准四元组（这里的“标准”指a < b < c < d），
即可将其改变顺序，拓展出8个满足题意的四元组。而如果我们将其变为[1, 2, 3, 4, 6, 12]，则可以找到[1,2,6,12]，[1,3,4,12] 以及[2,3,4,6] 三个标准四元组，可以发现，
这三个标准四元组实际即为三个二元组 [1,12]，[2,6] 以及 [3,4] 的两两组合，而这三个二元组满足的条件是乘积为 12。所以，我们进一步简化问题，
只要利用哈希表记录每个不同乘积对应的二元组数目，并将其两两组合，即可得到不同的标准四元组。

计算过程
假设一个乘积 x 出现的次数为 y，则其对应的二元组数目有 y个。这些二元组两两组合，形成的标准四元组个数为 Cy2。
根据前面的分析，一个标准四元组可以通过改变顺序，拓展为 8个满足题意的解，故可得到的解为 8Cy2。
我们遍历整个哈希表，将所有乘积 x 对应的解个数相加即可。
class Solution {
public:
    int tupleSameProduct(vector<int>& nums) {
        int res = 0;
        int n = nums.size();
        unordered_map<int ,int> mp;
        for(int i=0;i < n;++i){
            for(int j=i+1;j<n;j++){
                mp[nums[i]*nums[j]]++;
            }
        }
        for(auto c : mp){
            res += c.second * (c.second-1) / 2 * 8;
        }
        return res;
    }
};
